<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Rocket Game - Launch From Surface (With Trajectory)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
    body { margin:0; overflow:hidden; background:#050505; color:#fff; font-family: "Courier New", monospace; }
    canvas { display:block; }
    #ui-layer {
        position: absolute; top: 18px; left: 18px;
        pointer-events: none;
        background: rgba(0,0,0,0.55);
        padding: 10px; border-radius: 6px; border:1px solid #333; z-index:5;
    }
    .hud-text { font-size:14px; line-height:1.3; }
    #minimap-container { width:150px; height:150px; margin-top:8px; border:1px solid #00aaff; background:rgba(0,0,0,0.6); overflow:hidden; }
    #message-overlay {
        position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
        display:none; z-index:10; min-width:320px;
        background: rgba(0,20,50,0.95); padding:32px; border:2px solid #00aaff; border-radius:10px; text-align:center;
    }
    #message-overlay h1 { margin:0 0 12px; font-size:22px; color:#00aaff; }
    #message-overlay p { margin:0; font-size:15px; color:#ddd; }
    button { margin-top:16px; padding:10px 18px; background:#00aaff; border:none; color:white; border-radius:6px; cursor:pointer; }
    button:hover { background:#0088cc; }
    .error-msg { color:#ff6666 !important; font-weight:700; }
</style>
</head>
<body>
<div id="ui-layer">
    <div class="hud-text" id="hud-fuel">FUEL: 0</div>
    <div class="hud-text" id="hud-vel">VEL: 0</div>
    <div class="hud-text" id="hud-earth">DIST (Earth): 0</div>
    <div class="hud-text" id="hud-moon">DIST (Moon): 0</div>
    <div style="color:#aaa; font-size:11px; margin-top:6px; pointer-events:none;">
        操作: [↑]噴射 / [←][→]回転<br>目標: 月へ到達せよ
    </div>
    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>
</div>

<div id="message-overlay">
    <h1 id="msg-title">Loading...</h1>
    <p id="msg-desc">Please wait.</p>
    <button id="restart-btn" onclick="location.reload()">再挑戦 (Restart)</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/* -------------------------
   Canvas / Context
   ------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');

/* -------------------------
   定数（ゲームスケール）
   ------------------------- */
const G = 6;
const EARTH_MASS = 5000;
const EARTH_RADIUS = 800;
const EARTH_ROTATION_SPEED = 0.0;

const MOON_MASS = 5000/8;
const MOON_RADIUS = 200;
const MOON_INITIAL_DISTANCE = 3000;
const MOON_ORBIT_PERIOD = 40000;
const MOON_ORBIT_ECCENTRICITY = 0.1;

const ROCKET_THRUST = 0.05;
const ROTATION_SPEED = 0.02;
const FUEL_CONSUMPTION = 1.5;
const ROCKET_RADIUS = 10;

// ★ 軌跡用の定数
const TRAJECTORY_MAX_POINTS = 2000; // 保存する最大ポイント数
const TRAJECTORY_INTERVAL = 4;      // 何フレームごとに記録するか

/* -------------------------
   状態変数
   ------------------------- */
let width = window.innerWidth;
let height = window.innerHeight;
let camera = { x:0, y:0 };
let stars = [];
let keys = {};
let gameOver = false;
let moonOrbitAngle = Math.random() * Math.PI;

// ★ 軌跡データ配列
let trajectory = [];
let frameCount = 0;

const earth = { x:0, y:0, r: EARTH_RADIUS, m: EARTH_MASS, color: '#2E86C1' };
const moon  = { x:0, y:0, r: MOON_RADIUS, m: MOON_MASS, color: '#BDC3C7' };

const rocket = {
    x:0, y:0, vx:0, vy:0, angle:0,
    fuel:1000, maxFuel:1000, radius: ROCKET_RADIUS,
    active:false,
    landed:false
};

/* -------------------------
   初期化
   ------------------------- */
function resize(){
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    minimapCanvas.width = 150;
    minimapCanvas.height = 150;
}
window.addEventListener('resize', resize);
resize();

window.addEventListener('keydown', (e)=> { keys[e.code] = true; });
window.addEventListener('keyup', (e)=> { keys[e.code] = false; });

function createStars(){
    stars = [];
    for(let i=0;i<1500;i++){
        stars.push({ x:(Math.random()-0.5)*12000, y:(Math.random()-0.5)*12000, size: Math.random()*2 });
    }
}

/* -------------------------
   月の位置更新
   ------------------------- */
function updateMoonPosition(){
    moonOrbitAngle += (2*Math.PI / MOON_ORBIT_PERIOD);
    const a = MOON_INITIAL_DISTANCE;
    const e = MOON_ORBIT_ECCENTRICITY;
    const r_moon = a*(1-e*e) / (1 + e*Math.cos(moonOrbitAngle));
    moon.x = earth.x + r_moon * Math.cos(moonOrbitAngle);
    moon.y = earth.y + r_moon * Math.sin(moonOrbitAngle);
}

/* -------------------------
   ユーティリティ
   ------------------------- */
function getDistance(a,b){
    return Math.hypot(a.x - b.x, a.y - b.y);
}

/* -------------------------
   ゲームリセット
   ------------------------- */
function resetGame(){
    rocket.vx = 0;
    rocket.vy = 0;
    rocket.x = 0; 
    rocket.y = -earth.r - rocket.radius + 5;
    
    // 表面速度
    rocket.vx = 0;
    rocket.vy = rocket.x * EARTH_ROTATION_SPEED;

    rocket.angle = Math.atan2(rocket.y - earth.y, rocket.x - earth.x);

    rocket.fuel = rocket.maxFuel;
    rocket.active = false;
    rocket.landed = true;
    gameOver = false;
    keys = {};

    // ★ 軌跡のリセット
    trajectory = [];
    frameCount = 0;

    moonOrbitAngle = Math.random() * Math.PI;
    updateMoonPosition();

    camera.x = -rocket.x + width/2;
    camera.y = -rocket.y + height/2;

    document.getElementById('message-overlay').style.display = 'none';
    document.getElementById('msg-title').className = "";
    document.getElementById('restart-btn').style.display = 'inline-block';
}

/* -------------------------
   衝突判定
   ------------------------- */
function checkCollision(){
    if (rocket.landed) return;

    // 地球
    const dEarth = getDistance(rocket, earth);
    if (dEarth < earth.r + rocket.radius) {
        const speed = Math.hypot(rocket.vx, rocket.vy);
        endGame("Mission Failed", `地球に激突しました。速度: ${speed.toFixed(1)}`);
        return;
    }

    // 月
    const dMoon = getDistance(rocket, moon);
    if (dMoon < moon.r + rocket.radius) {
        const speed = Math.hypot(rocket.vx, rocket.vy);
        if (speed < 3) {
            endGame("Success!", "月面着陸成功！おめでとうございます。");
        } else {
            endGame("Mission Failed", `月面に激突しました。速度: ${speed.toFixed(1)} (安全速度: 3.0未満)`);
        }
    }
}

/* -------------------------
   重力
   ------------------------- */
function applyGravity(body){
    const dx = body.x - rocket.x;
    const dy = body.y - rocket.y;
    const distSq = dx*dx + dy*dy;
    const dist = Math.sqrt(distSq);
    if (dist < 1) return;
    const force = G * body.m / distSq;
    rocket.vx += force * (dx/dist);
    rocket.vy += force * (dy/dist);
}

/* -------------------------
   更新ループ
   ------------------------- */
function updatePhysics(){
    if (gameOver) return;
    frameCount++;

    updateMoonPosition();

    if (rocket.landed) {
        rocket.angle = Math.atan2(rocket.y - earth.y, rocket.x - earth.x);
        if (keys['ArrowUp'] && rocket.fuel > 0) {
            const lift = rocket.radius + 2;
            const nx = Math.cos(rocket.angle);
            const ny = Math.sin(rocket.angle);
            rocket.x += nx * lift;
            rocket.y += ny * lift;
            rocket.vx += nx * ROCKET_THRUST * 4;
            rocket.vy += ny * ROCKET_THRUST * 4;
            rocket.active = true;
            rocket.landed = false;
            rocket.fuel = Math.max(0, rocket.fuel - FUEL_CONSUMPTION * 4);
        }
        return;
    }

    if (rocket.active) {
        if (keys['ArrowLeft']) rocket.angle -= ROTATION_SPEED;
        if (keys['ArrowRight']) rocket.angle += ROTATION_SPEED;
        if (keys['ArrowUp'] && rocket.fuel > 0) {
            rocket.vx += Math.cos(rocket.angle) * ROCKET_THRUST;
            rocket.vy += Math.sin(rocket.angle) * ROCKET_THRUST;
            rocket.fuel -= FUEL_CONSUMPTION;
        }
    }

    applyGravity(earth);
    applyGravity(moon);

    rocket.x += rocket.vx;
    rocket.y += rocket.vy;

    // ★ 軌跡データの記録（着地中は記録しない）
    if (!rocket.landed && frameCount % TRAJECTORY_INTERVAL === 0) {
        trajectory.push({x: rocket.x, y: rocket.y});
        // 長くなりすぎたら古いものを削除
        if (trajectory.length > TRAJECTORY_MAX_POINTS) {
            trajectory.shift();
        }
    }

    checkCollision();
    if (rocket.fuel < 0) rocket.fuel = 0;
}

/* -------------------------
   描画関連
   ------------------------- */
function drawBody(body) {
    if (body === earth) {
        const grad = ctx.createRadialGradient(
            body.x - body.r * 0.3, body.y - body.r * 0.3, body.r * 0.2,
            body.x, body.y, body.r
        );
        grad.addColorStop(0, "#5dade2");
        grad.addColorStop(0.5, "#2874a6");
        grad.addColorStop(1, "#0b3d91");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(body.x, body.y, body.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(120,180,255,0.25)";
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.arc(body.x, body.y, body.r + 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.lineWidth = 1;
        return;
    }
    if (body === moon) {
        const grad = ctx.createRadialGradient(
            body.x - body.r * 0.4, body.y - body.r * 0.4, body.r * 0.2,
            body.x, body.y, body.r
        );
        grad.addColorStop(0, "#eeeeee");
        grad.addColorStop(1, "#9e9e9e");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(body.x, body.y, body.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "rgba(0,0,0,0.15)";
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const r = body.r * 0.5;
            ctx.beginPath();
            ctx.arc(body.x + Math.cos(a) * r, body.y + Math.sin(a) * r, body.r * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }
        return;
    }
}

function drawRocket() {
    ctx.save();
    ctx.translate(rocket.x, rocket.y);
    ctx.rotate(rocket.angle + Math.PI / 2);

    ctx.fillStyle = "#f5f5f5";
    ctx.beginPath();
    ctx.ellipse(0, 0, 5, 11, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#ff000083";
    ctx.beginPath();
    ctx.moveTo(0, -18);
    ctx.quadraticCurveTo(10, -6, 0, -4);
    ctx.quadraticCurveTo(-10, -6, 0, -18);
    ctx.fill();

    ctx.fillStyle = "#5dade2";
    ctx.beginPath();
    ctx.arc(0, -2, 3.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle = "#c0392b";
    ctx.beginPath(); ctx.moveTo(-6, 6); ctx.lineTo(-14, 12); ctx.lineTo(-6, 10); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(6, 6); ctx.lineTo(14, 12); ctx.lineTo(6, 10); ctx.closePath(); ctx.fill();

    if (rocket.active && keys["ArrowUp"] && rocket.fuel > 0) {
        const flameLength = 12 + Math.random() * 6;
        ctx.fillStyle = "rgba(255,170,50,0.9)";
        ctx.beginPath(); ctx.moveTo(-3, 14); ctx.quadraticCurveTo(0, 14 + flameLength, 3, 14); ctx.closePath(); ctx.fill();
        ctx.fillStyle = "rgba(255,240,180,0.9)";
        ctx.beginPath(); ctx.moveTo(-1.5, 14); ctx.quadraticCurveTo(0, 14 + flameLength * 0.6, 1.5, 14); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
}

// ★ 軌跡描画関数（メイン画面用）
function drawTrajectory() {
    if (trajectory.length < 2) return;

    ctx.save();
    // カメラ位置を考慮
    ctx.translate(camera.x, camera.y);
    
    ctx.strokeStyle = "rgba(100, 255, 100, 0.4)"; // 薄い緑色
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';

    ctx.beginPath();
    ctx.moveTo(trajectory[0].x, trajectory[0].y);
    for (let i = 1; i < trajectory.length; i++) {
        ctx.lineTo(trajectory[i].x, trajectory[i].y);
    }
    ctx.stroke();

    ctx.restore();
}

function draw(){
    const targetCamX = -rocket.x + width/2;
    const targetCamY = -rocket.y + height/2;
    if (!isNaN(targetCamX) && !isNaN(targetCamY)) {
        camera.x += (targetCamX - camera.x) * 0.12;
        camera.y += (targetCamY - camera.y) * 0.12;
    }

    // 背景
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    ctx.translate(camera.x, camera.y);

    // 星
    ctx.fillStyle = 'white';
    for (let s of stars) {
        const sx = s.x + camera.x;
        const sy = s.y + camera.y;
        if (sx > -60 && sx < width + 60 && sy > -60 && sy < height + 60) {
            ctx.globalAlpha = Math.random() * 0.6 + 0.25;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1.0;
    
    ctx.restore(); // 一旦restoreして描画順序整理

    // ★ 軌跡を描画 (天体より下に描きたいのでここで呼ぶ)
    drawTrajectory();

    ctx.save();
    ctx.translate(camera.x, camera.y);

    drawBody(earth);
    drawBody(moon);
    drawRocket();

    // 速度予測ベクトル
    ctx.strokeStyle = 'rgba(255, 111, 0, 0.36)';
    ctx.beginPath();
    ctx.moveTo(rocket.x, rocket.y);
    ctx.lineTo(rocket.x + rocket.vx * 30, rocket.y + rocket.vy * 30);
    ctx.stroke();

    ctx.restore();

    updateUI();
    drawMinimap();
    drawTargetArrows();
}

function updateUI(){
    const speed = Math.hypot(rocket.vx, rocket.vy).toFixed(1);
    const distEarth = Math.max(0, Math.hypot(rocket.x-earth.x, rocket.y-earth.y) - earth.r - rocket.radius).toFixed(0);
    const distMoon  = Math.max(0, Math.hypot(rocket.x-moon.x, rocket.y-moon.y) - moon.r - rocket.radius).toFixed(0);

    const fuelEl = document.getElementById('hud-fuel');
    fuelEl.innerText = `FUEL: ${Math.floor(rocket.fuel)}`;
    fuelEl.style.color = rocket.fuel < 200 ? 'red' : 'white';

    document.getElementById('hud-vel').innerText = `VEL: ${speed} m/s`;
    document.getElementById('hud-earth').innerText = `DIST (Earth): ${distEarth} px`;
    document.getElementById('hud-moon').innerText  = `DIST (Moon): ${distMoon} px`;
}

// ★ ミニマップ描画（軌跡含む）
function drawMinimap(){
    minimapCtx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
    const scale = 0.02;
    const cx = minimapCanvas.width/2;
    const cy = minimapCanvas.height/2;

    // ★ ミニマップ上の軌跡
    if (trajectory.length > 1) {
        minimapCtx.strokeStyle = "rgba(100, 255, 100, 0.6)";
        minimapCtx.lineWidth = 1;
        minimapCtx.beginPath();
        // 最初の点
        minimapCtx.moveTo(
            cx + (trajectory[0].x - earth.x) * scale,
            cy + (trajectory[0].y - earth.y) * scale
        );
        // 残りの点
        for (let i = 1; i < trajectory.length; i++) {
            minimapCtx.lineTo(
                cx + (trajectory[i].x - earth.x) * scale,
                cy + (trajectory[i].y - earth.y) * scale
            );
        }
        minimapCtx.stroke();
    }

    // rocket
    minimapCtx.fillStyle = 'white';
    minimapCtx.beginPath();
    minimapCtx.arc(cx + (rocket.x - earth.x)*scale, cy + (rocket.y - earth.y)*scale, 2, 0, Math.PI*2);
    minimapCtx.fill();

    // earth
    minimapCtx.fillStyle = earth.color;
    minimapCtx.beginPath();
    minimapCtx.arc(cx, cy, earth.r*scale, 0, Math.PI*2);
    minimapCtx.fill();

    // moon
    minimapCtx.fillStyle = moon.color;
    minimapCtx.beginPath();
    minimapCtx.arc(cx + (moon.x - earth.x)*scale, cy + (moon.y - earth.y)*scale, moon.r*scale, 0, Math.PI*2);
    minimapCtx.fill();
}

function drawTargetArrows(){
    if (!isFinite(rocket.x) || !isFinite(moon.x)) return;
    const arrowSize = 18;
    const margin = 36;
    const rocketScreenX = rocket.x + camera.x;
    const rocketScreenY = rocket.y + camera.y;
    const radius = Math.max(60, Math.min(width, height) * 0.42 - margin - arrowSize);

    function drawArrowTo(tx, ty, color){
        const targetScreenX = tx + camera.x;
        const targetScreenY = ty + camera.y;
        if (targetScreenX > 0 && targetScreenX < width && targetScreenY > 0 && targetScreenY < height) return;
        const dx = tx - rocket.x;
        const dy = ty - rocket.y;
        const angle = Math.atan2(dy, dx);
        const arrowX = rocketScreenX + Math.cos(angle) * radius;
        const arrowY = rocketScreenY + Math.sin(angle) * radius;
        ctx.save();
        ctx.translate(arrowX, arrowY);
        ctx.rotate(angle);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(arrowSize, 0);
        ctx.lineTo(0, -arrowSize/3);
        ctx.lineTo(0, arrowSize/3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    drawArrowTo(moon.x, moon.y, moon.color);
    drawArrowTo(earth.x, earth.y, earth.color);
}

function endGame(title, desc){
    if (gameOver) return;
    gameOver = true;
    const titleEl = document.getElementById('msg-title');
    titleEl.innerText = title;
    titleEl.className = (title === "Success!") ? "" : "error-msg";
    document.getElementById('msg-desc').innerText = desc;
    document.getElementById('message-overlay').style.display = 'block';
}

function loop(){
    updatePhysics();
    draw();
    requestAnimationFrame(loop);
}

// エラーハンドラー
window.onerror = function(message, source, lineno, colno, error) {
    window.onerror = null;
    try {
        const overlay = document.getElementById('message-overlay');
        const title = document.getElementById('msg-title');
        const desc = document.getElementById('msg-desc');
        const btn = document.getElementById('restart-btn');
        if (overlay && title && desc) {
            overlay.style.display = 'block';
            title.innerText = "Error Occurred";
            title.className = "error-msg";
            desc.innerHTML = `プログラムエラーが発生しました。<br>${message}<br>Line: ${lineno}`;
            if (btn) btn.style.display = 'none';
        }
    } catch (e) {}
    return false; 
};

createStars();
resetGame();
loop();
</script>
</body>
</html>
