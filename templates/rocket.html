<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Rocket Game - Launch From Surface</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
    body { margin:0; overflow:hidden; background:#050505; color:#fff; font-family: "Courier New", monospace; }
    canvas { display:block; }
    #ui-layer {
        position: absolute; top: 18px; left: 18px;
        pointer-events: none;
        background: rgba(0,0,0,0.55);
        padding: 10px; border-radius: 6px; border:1px solid #333; z-index:5;
    }
    .hud-text { font-size:14px; line-height:1.3; }
    #minimap-container { width:150px; height:150px; margin-top:8px; border:1px solid #00aaff; background:rgba(0,0,0,0.6); overflow:hidden; }
    #message-overlay {
        position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
        display:none; z-index:10; min-width:320px;
        background: rgba(0,20,50,0.95); padding:32px; border:2px solid #00aaff; border-radius:10px; text-align:center;
    }
    #message-overlay h1 { margin:0 0 12px; font-size:22px; color:#00aaff; }
    #message-overlay p { margin:0; font-size:15px; color:#ddd; }
    button { margin-top:16px; padding:10px 18px; background:#00aaff; border:none; color:white; border-radius:6px; cursor:pointer; }
    button:hover { background:#0088cc; }
    .error-msg { color:#ff6666 !important; font-weight:700; }
</style>
</head>
<body>
<div id="ui-layer">
    <div class="hud-text" id="hud-fuel">FUEL: 0</div>
    <div class="hud-text" id="hud-vel">VEL: 0</div>
    <div class="hud-text" id="hud-earth">DIST (Earth): 0</div>
    <div class="hud-text" id="hud-moon">DIST (Moon): 0</div>
    <div style="color:#aaa; font-size:11px; margin-top:6px; pointer-events:none;">
        操作: [↑]噴射 / [←][→]回転（着地中は回転固定）<br>目標: 月へ到達せよ
    </div>
    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>
</div>

<div id="message-overlay">
    <h1 id="msg-title">Loading...</h1>
    <p id="msg-desc">Please wait.</p>
    <button id="restart-btn" onclick="location.reload()">再挑戦 (Restart)</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/* -------------------------
   エラーハンドリング（簡易）
   ------------------------- */
window.onerror = function(message, source, lineno, colno, error) {
    // 無限再帰防止
    window.onerror = null;

    try {
        const overlay = document.getElementById('message-overlay');
        const title = document.getElementById('msg-title');
        const desc = document.getElementById('msg-desc');
        const btn = document.getElementById('restart-btn');

        if (!overlay || !title || !desc) {
            console.error("Error occurred before UI was ready:", message);
            return false;
        }

        overlay.style.display = 'block';
        title.innerText = "Error Occurred";
        title.className = "error-msg";
        desc.innerHTML = `プログラムエラーが発生しました。<br>${message}<br>Line: ${lineno}`;
        if (btn) btn.style.display = 'none';
    } catch (e) {
        console.error("Error inside error handler:", e);
    }

    return false; // コンソールにも出す
};

/* -------------------------
   Canvas / Context
   ------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');

/* -------------------------
   定数（ゲームスケール）
   ------------------------- */
const G = 6;                      // 重力スケール（ゲーム調整）
const EARTH_MASS = 5000;
const EARTH_RADIUS = 800;
const EARTH_ROTATION_SPEED = 0.005; // 地球自転（ゲーム内）
const EARTH_SAFE_LANDING_SPEED = 1.0; // 地球の安全着地相対速度

const MOON_MASS = 5000/8;
const MOON_RADIUS = 200;
const MOON_INITIAL_DISTANCE = 3000;
const MOON_ORBIT_PERIOD = 40000;
const MOON_ORBIT_ECCENTRICITY = 0.1;

const ROCKET_THRUST = 0.05;
const ROTATION_SPEED = 0.02;
const FUEL_CONSUMPTION = 1.5;
const ROCKET_RADIUS = 10;

/* -------------------------
   状態変数
   ------------------------- */
let width = window.innerWidth;
let height = window.innerHeight;
let camera = { x:0, y:0 };
let stars = [];
let keys = {};
let gameOver = false;
let moonOrbitAngle = Math.random() * Math.PI * 2;

const earth = { x:0, y:0, r: EARTH_RADIUS, m: EARTH_MASS, color: '#2E86C1' };
const moon  = { x:0, y:0, r: MOON_RADIUS, m: MOON_MASS, color: '#BDC3C7' };

const rocket = {
    x:0, y:0, vx:0, vy:0, angle:0,
    fuel:1000, maxFuel:1000, radius: ROCKET_RADIUS,
    active:false,   // 動作中か（飛行中か）
    landed:false    // 着地中か
};

/* -------------------------
   初期化
   ------------------------- */
function resize(){
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    minimapCanvas.width = 150;
    minimapCanvas.height = 150;
}
window.addEventListener('resize', resize);
resize();

window.addEventListener('keydown', (e)=> { keys[e.code] = true; });
window.addEventListener('keyup', (e)=> { keys[e.code] = false; });

function createStars(){
    stars = [];
    for(let i=0;i<800;i++){
        stars.push({ x:(Math.random()-0.5)*12000, y:(Math.random()-0.5)*12000, size: Math.random()*2 });
    }
}

/* -------------------------
   月の位置更新
   ------------------------- */
function updateMoonPosition(){
    moonOrbitAngle += (2*Math.PI / MOON_ORBIT_PERIOD);
    const a = MOON_INITIAL_DISTANCE;
    const e = MOON_ORBIT_ECCENTRICITY;
    const r_moon = a*(1-e*e) / (1 + e*Math.cos(moonOrbitAngle));
    moon.x = earth.x + r_moon * Math.cos(moonOrbitAngle);
    moon.y = earth.y + r_moon * Math.sin(moonOrbitAngle);
}

/* -------------------------
   ユーティリティ
   ------------------------- */
function getDistance(a,b){
    return Math.hypot(a.x - b.x, a.y - b.y);
}

/* -------------------------
   ゲームリセット（最初は地表にいる）
   ------------------------- */
function resetGame(){
    rocket.vx = 0;
    rocket.vy = 0;
    // ロケットを地表の右端に配置（例）
    rocket.x = 0; // 地球中心 (0,0) を基準
    rocket.y = -earth.r - rocket.radius + 5;

    // 地表の自転に応じた表面速度（接線）
    const surfaceSpeed = (rocket.x) * EARTH_ROTATION_SPEED;
    // 右側（+x）の場所では接線は上向き（-y）方向。だがここでは表面速度は反時計回りを仮定して逆向き
    rocket.vx = 0;
    rocket.vy = rocket.x * EARTH_ROTATION_SPEED;

    // 向きは地表法線方向（地球中心→ロケットの方向）
    rocket.angle = Math.atan2(rocket.y - earth.y, rocket.x - earth.x);

    rocket.fuel = rocket.maxFuel;
    rocket.active = false;  // 地表にいて発射準備（未発射）
    rocket.landed = true;   // 着地状態（打ち上げ準備）
    gameOver = false;
    keys = {};

    // 月を初期化
    moonOrbitAngle = Math.random() * Math.PI * 2;
    updateMoonPosition();

    camera.x = -rocket.x + width/2;
    camera.y = -rocket.y + height/2;

    document.getElementById('message-overlay').style.display = 'none';
    document.getElementById('msg-title').className = "";
    document.getElementById('restart-btn').style.display = 'inline-block';
}

/* -------------------------
   衝突・着地判定（着地中は判定スキップ）
   ------------------------- */
function checkCollision(){
    // 着地中は衝突判定をスキップ（位置拘束は別に行われる）
    if (rocket.landed) return;

    // 地球
    const dEarth = getDistance(rocket, earth);
    if (dEarth < earth.r + rocket.radius) {
        // 単位法線（地球中心 → ロケット）
        const nx = (rocket.x - earth.x) / dEarth;
        const ny = (rocket.y - earth.y) / dEarth;

        // 表面接線（右手回転）
        const tx = -ny;
        const ty = nx;

        // 表面自転速度（位置に依存）
        const surfaceSpeed = dEarth * EARTH_ROTATION_SPEED;
        const surfaceVx = tx * surfaceSpeed;
        const surfaceVy = ty * surfaceSpeed;

        // 相対速度
        const relVx = rocket.vx - surfaceVx;
        const relVy = rocket.vy - surfaceVy;
        const relSpeed = Math.hypot(relVx, relVy);

        if (relSpeed < EARTH_SAFE_LANDING_SPEED) {
            // ソフトランディング
            rocket.vx = surfaceVx;
            rocket.vy = surfaceVy;

            // 地表に厳密に固定（位置修正）
            rocket.x = earth.x + nx * (earth.r + rocket.radius);
            rocket.y = earth.y + ny * (earth.r + rocket.radius);

            // 向きを法線方向に
            rocket.angle = Math.atan2(ny, nx);

            rocket.active = false;
            rocket.landed = true;
            // 着地時のメッセージ（任意）
            // endGame("Landed", "地球にソフトランディングしました。");
        } else {
            endGame("Mission Failed", `地球に激突しました。速度: ${relSpeed.toFixed(1)}`);
        }
        return;
    }

    // 月の判定（従来通り）
    const dMoon = getDistance(rocket, moon);
    if (dMoon < moon.r + rocket.radius) {
        const speed = Math.hypot(rocket.vx, rocket.vy);
        if (speed < 3) {
            endGame("Success!", "月面着陸成功！おめでとうございます。");
        } else {
            endGame("Mission Failed", `月面に激突しました。速度: ${speed.toFixed(1)} (安全速度: 3.0未満)`);
        }
    }
}

/* -------------------------
   重力適用
   ------------------------- */
function applyGravity(body){
    const dx = body.x - rocket.x;
    const dy = body.y - rocket.y;
    const distSq = dx*dx + dy*dy;
    const dist = Math.sqrt(distSq);
    if (dist < 1) return;
    const force = G * body.m / distSq;
    rocket.vx += force * (dx/dist);
    rocket.vy += force * (dy/dist);
}

/* -------------------------
   ゲームループ - 更新
   ------------------------- */
function updatePhysics(){
    if (gameOver) return;

    // 月の公転更新
    updateMoonPosition();

    // 着地中の操作
    if (rocket.landed) {
        // 着地中は回転固定（法線方向） - 回転キーで角度を変えたければ許可することも可能
        rocket.angle = Math.atan2(rocket.y - earth.y, rocket.x - earth.x);

        // 再離陸処理：着地中に上キーを押したら離陸
        if (keys['ArrowUp'] && rocket.fuel > 0) {
            // 法線方向へ少し持ち上げる（衝突判定回避）
            const lift = rocket.radius + 2; // 余裕を持たせる
            const nx = Math.cos(rocket.angle);
            const ny = Math.sin(rocket.angle);

            rocket.x += nx * lift;
            rocket.y += ny * lift;

            // 少し初速を与える（前向きに thrust 相当）
            rocket.vx += nx * ROCKET_THRUST * 4;
            rocket.vy += ny * ROCKET_THRUST * 4;

            rocket.active = true;
            rocket.landed = false;

            // そのフレームの消費燃料（少しだけ）
            rocket.fuel = Math.max(0, rocket.fuel - FUEL_CONSUMPTION * 4);
        }

        // 着地中はそれ以上の更新を行わない
        return;
    }

    // 飛行中の入力
    if (rocket.active) {
        if (keys['ArrowLeft']) rocket.angle -= ROTATION_SPEED;
        if (keys['ArrowRight']) rocket.angle += ROTATION_SPEED;

        if (keys['ArrowUp'] && rocket.fuel > 0) {
            rocket.vx += Math.cos(rocket.angle) * ROCKET_THRUST;
            rocket.vy += Math.sin(rocket.angle) * ROCKET_THRUST;
            rocket.fuel -= FUEL_CONSUMPTION;
        }
    }

    // 重力
    applyGravity(earth);
    applyGravity(moon);

    // 移動
    rocket.x += rocket.vx;
    rocket.y += rocket.vy;

    // 衝突判定
    checkCollision();

    // 燃料下限
    if (rocket.fuel < 0) rocket.fuel = 0;
}

/* -------------------------
   描画
   ------------------------- */
function drawBody(body) {
    // ---------- 地球 ----------
    if (body === earth) {
        const grad = ctx.createRadialGradient(
            body.x - body.r * 0.3,
            body.y - body.r * 0.3,
            body.r * 0.2,
            body.x,
            body.y,
            body.r
        );

        grad.addColorStop(0, "#5dade2");
        grad.addColorStop(0.5, "#2874a6");
        grad.addColorStop(1, "#0b3d91");

        // 本体
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(body.x, body.y, body.r, 0, Math.PI * 2);
        ctx.fill();

        // 大気
        ctx.strokeStyle = "rgba(120,180,255,0.25)";
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.arc(body.x, body.y, body.r + 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.lineWidth = 1;
        return;
    }

    // ---------- 月 ----------
    if (body === moon) {
        const grad = ctx.createRadialGradient(
            body.x - body.r * 0.4,
            body.y - body.r * 0.4,
            body.r * 0.2,
            body.x,
            body.y,
            body.r
        );

        grad.addColorStop(0, "#eeeeee");
        grad.addColorStop(1, "#9e9e9e");

        // 本体
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(body.x, body.y, body.r, 0, Math.PI * 2);
        ctx.fill();

        // クレーター（固定数・軽量）
        ctx.fillStyle = "rgba(0,0,0,0.15)";
        for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            const r = body.r * 0.5;
            ctx.beginPath();
            ctx.arc(
                body.x + Math.cos(a) * r,
                body.y + Math.sin(a) * r,
                body.r * 0.1,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }
        return;
    }

    

    // ---------- その他の天体（フォールバック） ----------
    ctx.fillStyle = body.color || "#ffffff";
    ctx.beginPath();
    ctx.arc(body.x, body.y, body.r, 0, Math.PI * 2);
    ctx.fill();
}

function drawRocket() {
    ctx.save();
    ctx.translate(rocket.x, rocket.y);
    ctx.rotate(rocket.angle + Math.PI / 2);

    // ===== 本体（丸っこい）=====
    ctx.fillStyle = "#f5f5f5";
    ctx.beginPath();
    ctx.ellipse(0, 0, 5, 11, 0, 0, Math.PI * 2);
    ctx.fill();

    // ===== 先端（赤い帽子）=====
    ctx.fillStyle = "#ff000083";
    ctx.beginPath();
    ctx.moveTo(0, -18);
    ctx.quadraticCurveTo(10, -6, 0, -4);
    ctx.quadraticCurveTo(-10, -6, 0, -18);
    ctx.fill();

    // ===== 窓 =====
    ctx.fillStyle = "#5dade2";
    ctx.beginPath();
    ctx.arc(0, -2, 3.5, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // ===== フィン（左右）=====
    ctx.fillStyle = "#c0392b";

    ctx.beginPath();
    ctx.moveTo(-6, 6);
    ctx.lineTo(-14, 12);
    ctx.lineTo(-6, 10);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(6, 6);
    ctx.lineTo(14, 12);
    ctx.lineTo(6, 10);
    ctx.closePath();
    ctx.fill();

    // ===== 噴射（可愛い炎）=====
    if (rocket.active && keys["ArrowUp"] && rocket.fuel > 0) {
        const flameLength = 12 + Math.random() * 6;

        ctx.fillStyle = "rgba(255,170,50,0.9)";
        ctx.beginPath();
        ctx.moveTo(-3, 14);
        ctx.quadraticCurveTo(0, 14 + flameLength, 3, 14);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "rgba(255,240,180,0.9)";
        ctx.beginPath();
        ctx.moveTo(-1.5, 14);
        ctx.quadraticCurveTo(0, 14 + flameLength * 0.6, 1.5, 14);
        ctx.closePath();
        ctx.fill();
    }

    ctx.restore();
}

function draw(){
    // カメラ追従（lerp）
    const targetCamX = -rocket.x + width/2;
    const targetCamY = -rocket.y + height/2;
    if (!isNaN(targetCamX) && !isNaN(targetCamY)) {
        camera.x += (targetCamX - camera.x) * 0.12;
        camera.y += (targetCamY - camera.y) * 0.12;
    }

    // 背景
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    ctx.translate(camera.x, camera.y);

    // 星
    ctx.fillStyle = 'white';
    for (let s of stars) {
        // 簡単な視界チェック
        const sx = s.x + camera.x;
        const sy = s.y + camera.y;
        if (sx > -60 && sx < width + 60 && sy > -60 && sy < height + 60) {
            ctx.globalAlpha = Math.random() * 0.6 + 0.25;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1.0;

    // 天体
    drawBody(earth, "EARTH");
    drawBody(moon, "MOON");
    drawRocket();


    // 軌跡予測簡易（速度ベクトル）
    ctx.strokeStyle = 'rgba(0,255,0,0.25)';
    ctx.beginPath();
    ctx.moveTo(rocket.x, rocket.y);
    ctx.lineTo(rocket.x + rocket.vx * 30, rocket.y + rocket.vy * 30);
    ctx.stroke();

    ctx.restore();

    // UI 更新
    updateUI();

    // ミニマップ
    drawMinimap();

    // 目標矢印
    drawTargetArrows();
}

/* -------------------------
   UI・ミニマップ
   ------------------------- */
function updateUI(){
    const speed = Math.hypot(rocket.vx, rocket.vy).toFixed(1);
    const distEarth = Math.max(0, Math.hypot(rocket.x-earth.x, rocket.y-earth.y) - earth.r - rocket.radius).toFixed(0);
    const distMoon  = Math.max(0, Math.hypot(rocket.x-moon.x, rocket.y-moon.y) - moon.r - rocket.radius).toFixed(0);

    const fuelEl = document.getElementById('hud-fuel');
    fuelEl.innerText = `FUEL: ${Math.floor(rocket.fuel)}`;
    fuelEl.style.color = rocket.fuel < 200 ? 'red' : 'white';

    document.getElementById('hud-vel').innerText = `VEL: ${speed} m/s`;
    document.getElementById('hud-earth').innerText = `DIST (Earth): ${distEarth} px`;
    document.getElementById('hud-moon').innerText  = `DIST (Moon): ${distMoon} px`;
}

function drawMinimap(){
    minimapCtx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
    const scale = 0.02;
    const cx = minimapCanvas.width/2;
    const cy = minimapCanvas.height/2;

    // rocket
    minimapCtx.fillStyle = 'white';
    minimapCtx.beginPath();
    minimapCtx.arc(cx + (rocket.x - earth.x)*scale, cy + (rocket.y - earth.y)*scale, 2, 0, Math.PI*2);
    minimapCtx.fill();

    // earth center
    minimapCtx.fillStyle = earth.color;
    minimapCtx.beginPath();
    minimapCtx.arc(cx, cy, earth.r*scale, 0, Math.PI*2);
    minimapCtx.fill();

    // moon
    minimapCtx.fillStyle = moon.color;
    minimapCtx.beginPath();
    minimapCtx.arc(cx + (moon.x - earth.x)*scale, cy + (moon.y - earth.y)*scale, moon.r*scale, 0, Math.PI*2);
    minimapCtx.fill();
}

/* -------------------------
   目標矢印（画面端）
   ------------------------- */
/* -------------------------
   目標矢印（ロケット中心の円上に表示）
   ------------------------- */
function drawTargetArrows(){
    if (!isFinite(rocket.x) || !isFinite(moon.x)) return;
    const arrowSize = 18;
    const margin = 36;

    // ロケットのスクリーン上の座標（camera の translate を考慮）
    const rocketScreenX = rocket.x + camera.x;
    const rocketScreenY = rocket.y + camera.y;

    // 円の半径（画面サイズに応じて適度に決める）
    const radius = Math.max(60, Math.min(width, height) * 0.42 - margin - arrowSize);

    // 描画ヘルパー：目標(tx,ty)へ向かう矢印を円周上に置く
    function drawArrowTo(tx, ty, color){
        // 目標のスクリーン位置
        const targetScreenX = tx + camera.x;
        const targetScreenY = ty + camera.y;

        // 目標が画面内にあるなら矢印は不要
        if (targetScreenX > 0 && targetScreenX < width && targetScreenY > 0 && targetScreenY < height) return;

        // ロケット中心からターゲット方向の角度
        const dx = tx - rocket.x;
        const dy = ty - rocket.y;
        const angle = Math.atan2(dy, dx);

        // 円周上の矢印位置（ロケット中心を原点）
        const arrowX = rocketScreenX + Math.cos(angle) * radius;
        const arrowY = rocketScreenY + Math.sin(angle) * radius;

        // 描画（矢印は +x 方向を向く三角形を回転して使う）
        ctx.save();
        ctx.translate(arrowX, arrowY);
        ctx.rotate(angle);

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(arrowSize, 0);
        ctx.lineTo(0, -arrowSize/3);
        ctx.lineTo(0, arrowSize/3);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    drawArrowTo(moon.x, moon.y, moon.color);
    drawArrowTo(earth.x, earth.y, earth.color);
}

/* -------------------------
   ゲーム終了表示
   ------------------------- */
function endGame(title, desc){
    if (gameOver) return;
    gameOver = true;
    const titleEl = document.getElementById('msg-title');
    titleEl.innerText = title;
    titleEl.className = (title === "Success!") ? "" : "error-msg";
    document.getElementById('msg-desc').innerText = desc;
    document.getElementById('message-overlay').style.display = 'block';
}

/* -------------------------
   メインループ
   ------------------------- */
function loop(){
    updatePhysics();
    draw();
    requestAnimationFrame(loop);
}

/* -------------------------
   起動処理
   ------------------------- */
createStars();
resetGame();
loop();

/* -------------------------
   Expose resetGame for button
   ------------------------- */
window.resetGame = function(){
    resetGame();
};

/* -------------------------
   小さな改善点：クリックでメッセージ閉じ
   ------------------------- */
document.getElementById('message-overlay').addEventListener('click', (e)=>{
    if (e.target.id === 'message-overlay') {
        document.getElementById('message-overlay').style.display = 'none';
    }
});
</script>
</body>
</html>
